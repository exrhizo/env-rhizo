#!/Users/exrhizo/env-rhizo/.venv/bin/python
import os, re, sys, argparse, fnmatch
from collections import Counter
from typing import Dict, List, Set, Tuple
from pathlib import PurePosixPath


# ctxtree --ignore ".git:__pycache__:.venv*:.venv-lint:node_modules:data:.mypy_cache:.ruff_cache:.pytest_cache:.tox:.nox:.cache:build:dist:htmlcov:.coverage:coverage.xml:site-packages:*.dist-info:*.egg-info:.ipynb_checkpoints:.DS_Store:.idea:.vscode:logs:tmp:*.log:.ssh:*.pem:*.key:*.7z:*.zip:*.tar:*.tgz:*.gz:*.bz2:*.so:*.dylib"

RESERVED: Set[str] = set("{}[]/,")
NUM_TAIL = re.compile(r'^(.*?)(\d+)(\.[^.]+)?$')
RANGE_TOKEN = re.compile(r'.*\[\d+-\d+].*')
SET_TOKEN = re.compile(r'.*\{[^}]+}.*')

def q(s: str) -> str:
    if RANGE_TOKEN.match(s) or SET_TOKEN.match(s) or not any(c in RESERVED for c in s):
        return s
    return '"' + s.replace('"', '\\"') + '"'

def compress_tail_range(names: List[str]) -> List[str]:
    groups: Dict[Tuple[str, str, int], List[int]] = {}
    rest: List[str] = []
    for n in names:
        m = NUM_TAIL.match(n)
        if m:
            pre, digits, suf = m.group(1), m.group(2), m.group(3) or ""
            w = len(digits)
            groups.setdefault((pre, suf, w), []).append(int(digits))
        else:
            rest.append(n)
    out: List[str] = []
    for (pre, suf, w), arr in groups.items():
        arr.sort()
        i = 0
        while i < len(arr):
            j = i
            while j + 1 < len(arr) and arr[j + 1] == arr[j] + 1:
                j += 1
            a, b = f"{arr[i]:0{w}d}", f"{arr[j]:0{w}d}"
            out.append(f"{pre}[{a}-{b}]{suf}" if j > i else f"{pre}{a}{suf}")
            i = j + 1
    return sorted(rest + out)

def set_compress(names: List[str], min_variants: int) -> List[str]:
    groups: Dict[Tuple[str, str], Set[str]] = {}
    singles: List[str] = []
    for s in names:
        if RANGE_TOKEN.match(s) or "/" in s:
            singles.append(s); continue
        p1 = s.rfind(".")
        if p1 < 0: singles.append(s); continue
        base, suf = s[:p1], s[p1:]
        p0 = base.rfind(".")
        if p0 < 0: singles.append(s); continue
        pre, var = base[:p0+1], base[p0+1:]
        if 1 <= len(var) <= 4 and var.isalnum():
            groups.setdefault((pre, suf), set()).add(var)
        else:
            singles.append(s)
    out: List[str] = singles[:]
    for (pre, suf), vs in groups.items():
        uniq = sorted(vs, key=lambda v: (len(v), v))
        if len(uniq) >= min_variants:
            out.append(f"{pre}" + "{" + ",".join(uniq) + "}" + f"{suf}")
        else:
            out.extend(f"{pre}{v}{suf}" for v in uniq)
    return sorted(out)

def summarize_ext(files: List[str]) -> str:
    exts = [os.path.splitext(f)[1][1:] or "noext" for f in files]
    return ",".join(f"{e}×{n}" if n > 1 else e for e, n in Counter(exts).most_common())

# --- ignore helpers (fnmatch on basename or relative path) ---
def should_ignore(rel: str, name: str, pats: List[str]) -> bool:
    posix_rel = PurePosixPath(rel).as_posix()
    for pat in pats:
        if not pat: continue
        if fnmatch.fnmatch(name, pat) or fnmatch.fnmatch(posix_rel, pat):
            return True
    return False

def emit(root: str, rel: str, full: bool, max_list: int, ignore: List[str], set_min: int) -> str:
    abs_dir = root if not rel else os.path.join(root, rel)
    try:
        entries = sorted(
            e for e in os.listdir(abs_dir)
            if not should_ignore(f"{rel}/{e}" if rel else e, e, ignore)
        )
    except Exception:
        return "⛔"

    files = [e for e in entries if os.path.isfile(os.path.join(abs_dir, e))]
    dirs  = [e for e in entries if os.path.isdir(os.path.join(abs_dir, e))]

    parts: List[str] = []
    if not full and len(files) > max_list:
        parts.append(summarize_ext(files))  # lossy
    else:
        names = set_compress(compress_tail_range(files), set_min)  # lossless
        parts += [q(x) for x in names]

    for d in dirs:
        c = emit(root, f"{rel}/{d}" if rel else d, full, max_list, ignore, set_min)
        parts.append(f"{q(d)}/{{{c}}}" if c else f"{q(d)}/")
    return ",".join(parts)

def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("root", nargs="?", default=".")
    ap.add_argument("--full", action="store_true",
                    help="lossless mode (no leaf summarization); keeps range + set compression")
    ap.add_argument("--max-list", type=int, default=int(os.getenv("CT_MAX_LIST", "12")))
    ap.add_argument("--set-min", type=int, default=int(os.getenv("CT_SET_MIN", "3")))
    # Default ignore now includes .venv and node_modules; flag overrides defaults.
    ap.add_argument(
        "--ignore",
        default=os.getenv("CT_IGNORE", ".git:__pycache__:.venv:node_modules"),
        help="colon-separated fnmatch patterns applied to basenames and relative paths (overrides defaults)"
    )
    ap.add_argument(
        "--blurb",
        action=argparse.BooleanOptionalAction, default=True,
        help="print one-line header describing the encoding (default: on)"
    )
    args = ap.parse_args()

    ignore_pats: List[str] = [p for p in args.ignore.split(":") if p]
    root = os.path.abspath(args.root)
    name = os.path.basename(root) or "."

    if args.blurb:
        mode = "lossless" if args.full else f"leaf-summarized>{args.max_list}"
        fmt = "[a-b]=num ranges; {a,b}=variants; quotes=reserved; ⛔=unreadable"
        print(f"# ctxtree: compact directory summary of '{name}' ({mode}; ignore={':'.join(ignore_pats)}; {fmt})")

    print(f"{q(name)}/{{{emit(root, '', args.full, args.max_list, ignore_pats, args.set_min)}}}")

if __name__ == "__main__":
    main()
